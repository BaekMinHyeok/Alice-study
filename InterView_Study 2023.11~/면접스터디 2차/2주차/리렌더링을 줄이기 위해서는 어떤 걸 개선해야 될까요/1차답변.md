답변 : 제가 생각하기에 리렌더링을 줄이기 위해 개선해야할 사항은 상태관리 최적화, 메모이제이션, 컴포넌트 분리, 데이터 패칭 최적화 등이 있습니다.

고차함수: 데이터 리스트를 필터링하거나 변환하는 기능, 비동기 함수와 콜백을 사용하여 데이터 로딩 후 후속 작업, 이벤트 핸들러를 등록하고, 다양한 이벤트를 처리하는 기능

-   상태관리 최적화
    상태 관리를 최적화하려면, 상태를 필요한 최소한의 컴포넌트에만 배치하고, 상태 변화가 최소한의 리렌더링을 유발하도록 해야 합니다.
    ```jsx
    import React, { useState } from "react";

    const Parent = () => {
        const [count, setCount] = useState(0);

        const handleClick = () => setCount(count + 1);

        return (
            <div>
                <Counter count={count} />
                <IncrementButton onClick={handleClick} />
            </div>
        );
    };

    const Counter = ({ count }) => {
        console.log("Counter render");
        return <h2>Count: {count}</h2>;
    };

    const IncrementButton = ({ onClick }) => {
        console.log("IncrementButton render");
        return <button onClick={onClick}>Increment</button>;
    };

    export default Parent;
    ```
    이 예제에서 `Counter`와 `IncrementButton` 컴포넌트를 분리하여 상태 변화가 필요한 부분만 리렌더링되도록 했습니다.
    ### 전역 상태 관리 **Zustand**를 사용
    -   로그인 후 사용자 이름과 배지 정보를 표시할 때, 전역 상태 관리 라이브러리인 Zustand를 활용하여 사용자 정보를 `store`에 저장했습니다. 이렇게 하면 여러 컴포넌트에서 동일한 데이터를 참조하고 사용할 수 있게 되어, 데이터 중복과 불필요한 리렌더링을 방지할 수 있었습니다.
    ### 리코일 사용
-   메모이제이션 사용
    ### React.memo
    `React.memo`는 고차 컴포넌트로, 주로 함수형 컴포넌트의 불필요한 리렌더링을 방지하기 위해 사용됩니다. props가 변경되지 않으면, 컴포넌트를 다시 렌더링하지 않습니다.
    주로 부모 컴포넌트가 자식 컴포넌트에 동일한 props를 전달할 때 불필요한 리렌더링을 막기 위해 사용합니다.
    ### 사용 예시
    ```jsx
    import React from "react";

    const MyComponent = React.memo(({ data }) => {
        return <div>{data}</div>;
    });
    ```
    ### 작동 방식
    -   `React.memo`는 컴포넌트를 감싸고, 이전 props와 새로운 props를 비교합니다.
    -   props가 동일하면 컴포넌트는 다시 렌더링되지 않습니다.
    -   객체나 배열과 같은 참조형 데이터 타입의 비교는 얕은 비교를 사용합니다.
    ### useMemo
    `useMemo`는 React 훅으로, 계산 비용이 높은 함수의 결과를 메모이제이션하여 성능을 최적화합니다. 특정 값이 변경될 때까지 이전 계산 결과를 재사용합니다.
    ### 사용 예시
    ```jsx
    import { useMemo } from "react";

    const MyComponent = ({ items }) => {
        const sortedItems = useMemo(() => {
            return items.sort((a, b) => a - b);
        }, [items]);

        return <div>{sortedItems.join(", ")}</div>;
    };
    ```
    ### 작동 방식
    -   `useMemo`는 첫 번째 인자로 전달된 함수의 반환 값을 메모이제이션합니다.
    -   두 번째 인자인 의존성 배열이 변경되지 않으면, 이전 계산 결과를 재사용합니다.
    -   계산 비용이 높은 연산이나 함수가 재실행되지 않도록 최적화할 때 유용합니다.
    ### useCallback
    **useCallback**은 컴포넌트 안에서 메모이제이션된 함수가 필요할 때 사용합니다. 주로 함수가 자식 컴포넌트에 props로 전달되거나 이벤트 핸들러로 사용될 때, 불필요한 함수 재생성을 방지하기 위해 사용합니다.
    ### 사용 예시
    ```jsx
    import { useCallback } from "react";

    const MyComponent = ({ onClick }) => {
        const handleClick = useCallback(() => {
            onClick();
        }, [onClick]);

        return <button onClick={handleClick}>Click me</button>;
    };
    ```
    ### 작동 방식
    -   `useCallback`은 첫 번째 인자로 전달된 함수를 메모이제이션합니다.
    -   두 번째 인자인 의존성 배열이 변경되지 않으면, 이전 함수 인스턴스를 재사용합니다.
    -   함수가 자주 재생성되는 것을 방지하여, 불필요한 렌더링을 방지할 때 유용합니다.
    ### 주요 차이점 요약
    1. **React.memo**:
        - 컴포넌트를 감싸서 불필요한 렌더링을 방지.
        - props가 변경되지 않으면 컴포넌트를 다시 렌더링하지 않음.
    2. **useMemo**:
        - 계산 비용이 높은 함수의 결과를 메모이제이션.
        - 특정 값이 변경될 때까지 이전 계산 결과를 재사용.
    3. **useCallback**:
        - 함수를 메모I제이션하여 동일한 함수 인스턴스를 반환.
        - 특정 값이 변경될 때까지 이전 함수 인스턴스를 재사용.
    ### 나의 프로젝트 예시
    -   프로필 이미지를 변경하는 컴포넌트를 추가하는 작업이 있었는데 이미지들이 변경될때 useCallback을 사용함으로써 함수가 불필요하게 재생성되는 것을 방지하고, 자식 컴포넌트에 전달될 때 불필요한 리렌더링을 줄일 수 있었습니다.
    -   추가한 부분은 첫 번째 이미지 클릭 시 파일 입력 요소를 트리거하는 함수이고 두 번째는 파일 입력 값이 변경되었을 때 호출되는 요소
-   컴포넌트 분리
    큰 컴포넌트를 작은 컴포넌트로 분리하여 필요한 부분만 리렌더링되도록 합니다.
-   데이터 패칭 최적화
    데이터 패칭을 useEffect와 메모이제이션으로 최적화하여 불필요한 네트워크 요청을 방지합니다. 또한, TanStack Query와 같은 라이브러리를 사용하여 데이터 패칭과 캐싱을 효율적으로 관리할 수 있습니다.
    **수정, 작성, 삭제**: 데이터의 수정, 작성, 삭제 작업에는 `useMutation`을 사용하여 서버와의 상호작용을 관리했습니다. `useMutation`을 통해 비동기 요청을 처리하고, 요청이 성공적으로 완료되면 관련된 데이터를 업데이트하거나 상태를 새로 고쳤습니다.
    ### TanStack Query 질문시
    -   `useQuery`는 서버에서 데이터를 패칭하고 캐싱하는 데 도움을 줍니다. 예를 들어, `useQuery`의 `queryKey`를 사용하여 데이터를 식별하고 서버에서 가져온 데이터를 효율적으로 캐싱하여, 같은 데이터를 여러 번 요청하지 않도록 했습니다.
-   꼬리꼬리➰ 자식 컴포넌트에서 리렌더링이 발생했을 때, 어디까지 리렌더링이 되나요?
    자식 컴포넌트에서 리렌더링이 발생할 때, 일반적으로 그 자식 컴포넌트와 그 자식 컴포넌트의 하위 컴포넌트들만 리렌더링됩니다. 부모 컴포넌트나 형제 컴포넌트는 영향을 받지 않습니다. 그러나 부모 컴포넌트가 리렌더링되면 모든 자식 컴포넌트도 다시 리렌더링될 수 있습니다.
    리액트의 리렌더링 메커니즘을 더 잘 이해하기 위해서는 다음 사항들을 고려할 수 있습니다:
    -   부모 컴포넌트의 상태나 props가 변경되면 부모와 모든 자식 컴포넌트가 리렌더링됩니다.
    -   자식 컴포넌트의 상태나 props가 변경되면 그 자식 컴포넌트와 하위 컴포넌트들만 리렌더링됩니다.
    -   `React.memo`를 사용하면 부모 컴포넌트가 리렌더링되어도 해당 자식 컴포넌트의 props가 변경되지 않는 한 자식 컴포넌트는 리렌더링되지 않습니다.
    -   "부모 컴포넌트가 리렌더링되면, 자식 컴포넌트도 함께 리렌더링됩니다. 자식 컴포넌트가 리렌더링되는 것은 `props`와 `state`가 변경되었기 때문입니다. 그러나 `React.memo`를 사용하면, 자식 컴포넌트의 `props`가 변경되지 않는 한 자식 컴포넌트는 리렌더링되지 않습니다. 또한, `useCallback`과 `useMemo`를 사용하여 자식 컴포넌트에 전달되는 `callback` 함수와 계산된 값을 메모이제이션함으로써 리렌더링을 최소화할 수 있습니다. 이러한 최적화 방법들은 성능을 향상시키고, 불필요한 리렌더링을 방지하는 데 도움을 줍니다."
