-   깊은 복사, 얕은 복사란 무엇인지 설명해주세요.
    **깊은복사**
    -   깊은 복사란, 기존 값의 모든 참조가 끊어지는 것을 말한다. 특히 복사할 때, 참조형 타입 값(객체)에서 내부에 있는 모든 값이 새로운 값이 되는 것을 말합니다.
    -   깊은 복사를 사용하면 복사했을 때 값은 동일하지만, 객체 내부의 값을 변경해도 서로 영향을 주지 않고 격리된 값을 보장합니다.
    -   원시값과 달리 객체는 변경이 가능한 ‘가변값’이며 프로퍼티의 집합입니다.
    -   자바스크립트는 객체 생성 이후에도 프로퍼티를 추가하거나 삭제하는 등 변경할 수 있다. 따라서, 깊은 복사를 통해 객체를 복사하지 않으면 객체 사이의 관계가 생성되어 예기치 못한 오류가 발생할 수 있습니다.
    -   **기본형 타입의 깊은 복사**
        ```tsx
        const a = 10;
        const b = 10;
        console.log(a === b); // true
        let c = 20;
        let d = c;
        console.log(c === d); // true

        d = 30;
        console.log(c); // 20
        console.log(d); // 30
        console.log(c === d); // false
        ```
        -   기본형 타입의 값을 바라보는 주소값이 동일하기 때문에 a와 b는 각각 값을 할당 받았지만 동일하다고 판단합니다.
        -   d도 마찬가지로 c의 주소를 넘겨받았기 때문에 동일하다고 판단합니다.
        -   c의 주소를 넘겨 받은 d에 30을 재할당 했습니다.
        -   c와 d는 다른 값을 바라보고 있습니다.
            > 내부의 값은 없지만 복사했을 때, 서로의 주소가 달라졌다. 기본형 타입의 깊은 복사입니다. **서로에게 영향을 주지 않습니다.**
    -   **참조형 타입의 깊은 복사**
        ```tsx
        const obj1 = {
            a: 10,
            b: "abc",
        };
        let obj2 = obj1;
        console.log(obj1 === obj2); // true

        obj2.a = 20;
        console.log(obj1); // {a: 20, b: 'abc'}
        console.log(obj2); // {a: 20, b: 'abc'}
        console.log(obj1 === obj2); // true
        ```
        -   obj1과 obj2가 가지고 있는 주소 값이 동일하기 때문에 true가 나왔습니다.
        -   obj2의 a프로퍼티의 값을 20으로 재할당했습니다.
        -   obj1, obj2의 값의 a 프로퍼티 모두 20으로 변경되었습니다.
        -   여전히 obj1과 obj2가 가지고 있는 주소 값이 동일합니다.
            > 결과가 나온 이유는, obj2의 ’**프로퍼티**‘를 변경시켰기 때문입니다. 프로퍼티 a가 바라보고 있는 주소 자체는 변경되었지만 obj1, obj2가 프로퍼티 ‘그룹’을 바라보는 주소자체는 변경되지 않은 것입니다. 이렇게 객체 자체의 참조 값을 할당하면, 깊은 복사가 일어나지 않습니다.
    **얕은 복사**
    -   얕은 복사란 참조형 타입의 값의 바로 아래 단계의 값만 복사하는 방법입니다.
        ```tsx
        const obj1 = {
            a: 1,
            b: {
                c: 2,
            },
        };
        const obj2 = { ...obj1 };
        console.log(obj1 === obj2); // false
        console.log(obj1.b === obj2.b); // true
        ```
        -   두 개의 객체는 다른 주소를 가지고 있지만, 객체 안 프로퍼티는 동일한 주소를 가지고 있습니다.
        -   `{}` 이 껍데기는 새로 생성된 객체이며 새로운 주소를 갖게 되었고 spread 연산자로 풀어진 프로퍼티들은 처음 선언된 obj1의 프로퍼티들이 사용되었습니다.
        -   얕은 복사를 만드는 방법은 위에 사용한 spread 연산자를 통해 만들 수도 있고 다른 방법으로도 만들 수 있습니다.
        -   spread 연산자는 객체 뿐 아니라 배열에서도 동일하게 동작합니다.
        -   Object.assign()
            ```tsx
            const obj1 = {
                a: 10,
                b: {
                    c: "abc",
                },
            };
            const obj2 = Object.assign({}, obj1);
            obj2.a = 20;
            obj2.b.c = "def";

            console.log(obj1); // { a: 10, b: { c: "def" } }
            console.log(obj2); // { a: 20, b: { c: "def" } }
            ```
            -   첫번째 인자로 `{}` 빈 객체가 들어갔기 때문에 껍데기가 obj1과 다른 객체가 반환 될 것입니다.
            -   obj1의 내용을 `{}` 빈 객체 안에 복사해서 집어넣고 반환합니다.
            -   프로퍼티 a는 기본형 타입의 값이 들어있기 때문에 변경하면 obj2의 a 프로퍼티만 변경됩니다.
            -   프로퍼티 b는 참조형 타입의 값이 들어있기 때문에 변경하면 obj1, obj2의 b가 가진 주소값이 동일하기 때문에 둘 다 변경됩니다.
    > 얕은 복사는 한 단계까지만 복사하고, 깊은 복사는 객체에 중첩된 객체까지 모두 복사합니다.
    > 얕은 복사와 깊은 복사 모두 복사한 대상에 대해서 새로운 객체를 생성하여 기존 객체에는 영향을 주지 않습니다.
    > 하지만 얕은 복사와 깊은 복사는 어느 수준까지 복사하느냐의 차이를 가집니다.
    > 얕은 복사를 하면 한 단계만 복사하기 때문에 중첩된 객체에 대해서는 서로 영향을 주고, 깊은 복사는 중첩된 객체 역시 별개의 값으로서 서로 영향을 주지 않습니다.
    **데이터 타입**
    -   기본형 타입에는 Number, String, Boolean, undefined, null, 그리고 ES6에서 추가된 Symbol이 있습니다.
    -   참조형 타입은 Object, Array, Function, Date, RegExp, 그리고 ES6에서 추가된 Map, WeakMap, Set, WeakSet이 있습니다
    -   기본형과 참조형을 구분할 수 있는 방법은, 할당이나 연산 시 값을 복사하면 기본형이고, 값을 복사할 때 참조하면 참조형입니다.
