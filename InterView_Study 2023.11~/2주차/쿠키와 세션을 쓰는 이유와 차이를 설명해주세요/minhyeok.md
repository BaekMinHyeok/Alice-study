-   쿠키와 세션을 쓰는 이유와 차이를 설명해주세요.

    -   **사용하는 이유**
        -   쿠키와 세션을 사용하는 이유는 서버와 클라이언트의 통신 프로토콜인 HTTP 의 비연결성( 요청에 대한 응답 보내고 연결 끊어버리기 ), 비상태성( 클라이언트의 정보를 유지하지 않음 )이라는 특징 때문입니다.
            -   클라이언트는 서버에게 request를 보냈을 때 그 request에 맞는 response를 보낸 후 연결을 끊습니다.
            -   서버는 클라이언트에 대한 상태 정보를 유지하지 않기 때문에 response를 보낸 후 에는 클라이언트에 대해 알 수 없게 됩니다.
                만약 쿠키와 세션을 사용하지 않는다면 웹사이트에 로그인을 했음에도 페이지를 이동할 때마다 계속 로그인을 해야한다.
                이러한 비연결성, 비상태성 때문에 쿠키와 세션을 사용해서 사용자를 인증한다.
    -   **쿠키**
        -   브라우저에 key-value쌍으로 로컬에 저장되는 데이터 파일이며, 유효시간 내에서는 브라우저가 종료되어도 계속 유지됩니다.
            **동작방식**
            -   서버가 클라이언트로부터 요청을 받았을 때, 클라이언트에 대한 정보를 바탕으로 set-cookie 속성을 사용해 “쿠키”를 만듭니다.
            -   서버는 클라이언트에게 해당 요청에 대한 응답을 보낼 때 응답의 Header부분에 쿠키를 담아 보냅니다.(서버로부터 쿠키가 담겨 오는 곳 : response header)
            -   클라이언트가 응답을 받으면 브라우저는 쿠키를 쿠키 디렉터리에 저장 후 또 다시 서버에 요청을 할 때 사용자가 가만히 있어도 브라우저가 request header에 쿠키를 담아서 서버에 전송합니다.
            -   서버는 또 다시 respinse에 쿠키 정보를 참조하여 응답합니다.
                ![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/976b641b-2e6b-431e-9b42-97c07d7d244f/f96a7976-d93a-4f40-a1be-30f9df89225c/Untitled.png)
            -   > 쿠키로 인해 HTTP의 비연결 상태에서도 클라이언트가(사용자가) 서버에게 자신을 "인증" 할 수 있게 된 것입니다.
                > **쿠키의 사용예시?**
            1. 방문 사이트에서 로그인 시, "아이디와 비밀번호를 저장하시겠습니까?"
            2. 팝업창을 통해 "오늘 이 창을 다시 보지 않기" 체크
    -   **세션**
        서버가 클라이언트를 구분하기 위해 응답에 쿠키를 포함할 때 session ID를 부여하고 클라이언트는 쿠키에 session ID를 저장해둔다.
        클라이언트(사용자)의 정보를 브라우저에 저장하는 쿠키와 달리 세션은 클라이언트의 정보를 서버에 저장한다.
        **세션의 특징**
        세션에는 유효기간이 있어 일정 시간 응답이 없다면 끊을 수 있고, 브라우저가 종료될 때까지 인증상태를 유지할 수 있다.
        사용자 정보를 서버에 두기 때문에 쿠키에 비하면 보안이 더 좋지만 서버에 저장하는 만큼 서버에 과부하를 줄 수 있고 성능저하의 요인이 된다.
    -   **차이점**

        -   세션도 쿠키를 사용하기 때문에 비슷한 역할을 하고 동작 원리도 비슷합니다.

        1. 사용자의 정보가 저장되는 위치
            - 쿠키는 서버의 자원을 전혀 사용하지 않으며, 세션은 서버의 자원을 사용합니다.
        2. 보안
            - 쿠키는 클라이언트 로컬에 저장되기 때문에 변질되거나 request에서 스니핑 당할 우려가 있어서 보안에 취약합니다
            - 세션은 쿠키를 이용해서 session-id만 저장하고 그것으로 구분하여 서버에서 처리하기 때문에 비교적 보안성이 높습니다.
        3. 라이프 사이클
            - 쿠키는 브라우저를 종료해도 정보가 유지 될 수 있으며 만료기간을 따로 지정해 쿠키를 삭제 할 때까지 유지할 수도 있습니다.
            - 세션은 만료기간을 정할 수 있긴 하지만 브라우저가 종료되면 만료기간에 상관없이 삭제됩니다.
        4. 속도
            - 쿠키는 정보가 클라이언트에 있기 때문에 서버에 요청 시 속도가 빠릅니다.
            - 세션은 정보가 서버에 있기 때문에 처리가 요구되어 비교적 속도가 느립니다.

    -   **캐시**

    **캐시(Cache)**는 웹 페이지 요소를 저장하기 위한 임시 저장소이고, 쿠키/세션은 정보를 저장하기 위해 사용된다.

    **캐시**는 웹 페이지를 빠르게 렌더링 할 수 있도록 도와주고, 쿠키/세션은 사용자의 인증을 도와준다.

    -   캐시는 이미지, 비디오, 오디오, css, js파일 등 데이터나 값을 미리 복사해 놓는 리소스 파일들의 임시 저장소이다.
    -   저장 공간이 작고 비용이 비싼 대신 빠른 성능을 제공한다.
    -   같은 웹 페이지에 접속할 때 사용자의 PC에서 로드하므로 서버를 거치지 않아도 된다.
    -   이전에 사용된 데이터가 다시 사용될 가능성이 많으면 캐시 서버에 있는 데이터를 사용한다.
    -   그래서 다시 사용될 확률이 있는 데이터들이 빠르게 접근할 수 있어진다. (페이지의 로딩 속도 ↑)
    -   캐시 히트(hit) : 캐시를 사용할 수 있는 경우 (ex. 이전에 왔던 요청이랑 같은 게 왔을 때)
    -   캐시 미스(miss) : 캐시를 사용할 수 없는 경우 (ex. 웹서버로 처음 요청했을 때)

-   **JWT토큰**
    **JWT 장점**
    -   JWT는 토큰 자체에 사용자의 정보가 저장되어 있어있기 때문에 서버 입장에서 토큰을 검증만 해주면 됩니다.
    -   JWT를 사용할 때는 사용자가 늘어나더라도 사용자 인증을 위해서 추가로 투자해야하는 인프라 비용을 크게 절감할 수 있습니다.
    -   쿠키와 세션을 사용할 때는 서버 단에 로그인한 모든 사용자의 세션을 DB나 캐시(cache)에 저장해놓고 쿠키로 넘어온 세션 ID로 사용자 데이터를 매번 조회해야만 합니다.
    **JWT 단점**
    -   Self-contained : 토큰 자체에 정보를 담고 있으므로 양날의 검이 될 수 있다.
    -   토큰 길이 : 토큰의 Payload에 3종류의 클레임을 저장하기 때문에, 정보가 많아질수록 토큰의 길이가 늘어나 네트워크에 부하를 줄 수 있다.
    -   Payload 인코딩 : payload 자체는 암호화 된 것이 아니라 BASE64로 인코딩 된 것이기 때문에, 중간에 Payload를 탈취하여 디코딩하면 데이터를 볼 수 있으므로, payload에 중요 데이터를 넣지 않아야 한다.
    -   Store Token : stateless 특징을 가지기 때문에, 토큰은 클라이언트 측에서 관리하고 저장한다. 때문에 토큰 자체를 탈취당하면 대처하기가 어렵게 된다.
    **CORS 문제 예**
    -   쿠키를 사용하는 경우, 브라우저는 동일 출처 정책(same-origin policy)에 따라 쿠키를 제한하여 동일한 도메인에서만 쿠키를 전송합니다.
    -   따라서 다른 도메인에서의 API 요청 시에는 쿠키가 전송되지 않아 인증이 유지되지 않을 수 있습니다. 이것이 CORS 문제의 한 예입니다.
    **JWT토큰 확장성으로 CORS 문제 해결방식**
    -   JWT를 사용하면 토큰이 HTTP 요청의 헤더에 직접 실려가기 때문에 브라우저는 이를 동일 출처 정책에 적용하지 않습니다.
    -   JWT를 헤더에 넣으면 서로 다른 도메인 간에도 자유롭게 토큰을 전송할 수 있습니다.
        이는 CORS 문제를 해결하는 데 도움이 됩니다.
    > JWT도 제 3자에게 토큰 탈취의 위험성이 있기 때문에, 그대로 사용하는것이 아닌 Access Token, Refresh Token 으로 이중으로 나누어 인증을 하는 방식을 현업에선 취한다.
    -   **Access Token** : **클라이언트**가 갖고있는 실제로 유저의 정보가 담긴 토큰으로, 클라이언트에서 요청이 오면 서버에서 해당 토큰에 있는 정보를 활용하여 사용자 정보에 맞게 응답을 진행
    -   **Refresh Token**: 새로운 Access Token을 발급해주기 위해 사용하는 토큰으로 짧은 수명을 가지는 Access Token에게 새로운 토큰을 발급해주기 위해 사용. 해당 토큰은 보통 **데이터베이스**에 유저 정보와 같이 기록.
