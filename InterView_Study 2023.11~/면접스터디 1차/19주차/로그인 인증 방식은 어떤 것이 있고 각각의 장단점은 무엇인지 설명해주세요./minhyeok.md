-   쿠키(Cookie)
    !https://user-images.githubusercontent.com/96133075/218945677-edcaf5ca-3527-4737-bf17-4e755552c5fe.png
    -   클라이언트에 저장될 목적으로 생성한 작은 정보를 담은 파일(서버에서 사용자 브라우저로 전송한다.)
    -   브라우저는 서버에서 받은 쿠키를 저장해두었다가, 동일한 서버로 재요청할 때 쿠키를 함께 전송한다.
    -   사용자가 로그인을 하면, 서버는 ID, PW 정보를 쿠키에 담아 브라우저로 다시 보낸다. 이후 브라우저에서는 요청할 때마다 로그인 정보가 담긴 쿠키를 함께 서버로 보낸다. 브라우저에서 매번 요청할 때마다 서버 입장에서는 로그인 정보가 담긴 쿠키를 받게 되는 것이다.
    -   사용자 인증이 유효한 시간을 명시할 수 있다.
        -   세션 쿠키: 만료 날짜를 생략하면 브라우저 종료시 까지만 유지(여기서의 세션은 쿠키의 종류 중 하나)
        -   영속 쿠키: 만료 날짜를 입력하면 해당 날짜까지 유지
    ### 쿠키의 장점
    -   기존 로그인 정보를 사용하기 때문에 인증을 위한 추가적인 데이터 저장이 필요 없다.(쿠키는 서버가 아닌 클라이언트 웹 브라우저에 한다.)
    ### 쿠키의 단점
    -   사용자의 주요 정보를 매번 요청에 담기 때문에 보안상 문제가 있다.
    -   클라이언트에서 쿠키 정보를 쉽게 변경, 삭제할 수 있고, 가로채기 당할 수도 있다.
    -   쿠키 사이즈가 커질수록 네트워크 부하가 심해진다.
-   세션(Session)
    !https://user-images.githubusercontent.com/96133075/218945723-446e9852-14a3-45f4-95dd-7a769c9f13b8.png
    -   서버에서 일정시간 동안 클라이언트 상태를 유지하기 위해 사용한다.
    -   서버에서 클라이언트별 유일한 세션 ID를 부여하고, 세션 정보를 서버에 저장한다.
        -   세션 ID : 사용자의 주요 정보가 아닌, 단지 사용자를 식별할 수 있는 값을 생성한다. → 보안 강화
    -   서버에서 생성한 세션 ID는 클라이언트의 쿠키 값(세션 쿠키)으로 저장되고, 클라이언트에서 요청을 보낼 때 이 세션 쿠키를 함께 보낸다. 서버에서는 클라이언트별 세션 쿠키 값이 저장되어 있으니, 요청으로 온 세션 쿠키 값을 보고 어떤 클라이언트인지 식별할 수 있다.
    ### 세션의 장점
    -   사용자의 로그인 정보를 주고 받지 않기 때문에 상대적으로 안전하다.
    -   사용자마다 고유한 세션 ID가 발급되기 때문에, 요청이 들어올 때마다 회원DB를 찾지 않아도 된다.
    ### 세션의 단점
    -   사용자를 식별할 수 있는 값인 세션 ID를 생성하고, 서버에 저장해야하는 작업이 생긴다.
    -   서버 세션 저장소를 사용하므로 요청이 많아지면 서버 부하가 심해진다.
-   JWT(JSON Web Token)
    -   JWT : 인증에 필요한 정보들을 암호화시킨 토큰
    -   JWT 토큰(Access Token)을 HTTP 헤더에 담아 서버가 클라이언트를 식별한다.
    ### JWT 구조
    -   Header
        -   토큰 타입, 해쉬 알고리즘(HS256 or RSA 등)으로 구성되어 있다.
            ```json
            {
                "alg": "HS256",
                "typ": "JWT"
            }
            ```
    -   Payload
        -   claim이 포함되는 영역으로, 토큰에 담을 정보를 갖고 있다.
            -   claim : key-value 형식으로 이루어진 한 쌍의 정보로, 엔티티(주로 사용자)에 대한 속성을 설명한다.
        -   클라이언트 고유 ID 값이나 유효 기간 등이 포함되는 영역이다.
            ```json
            {
                "sub": "1234567890",
                "username": "user1",
                "admin": true
            }
            ```
    -   Signature
        -   인코딩된 Header와 Payload를 더한 뒤, secret key로 해싱해서 생성한다. 이 때, 해싱 방법은 Header에서 지정한 해쉬 알고리즘 방법으로 한다.
        -   Header와 Payload는 단순히 인코딩된 값이어서 누구든 복호화가 가능하나, Signature는 서버 측에서 관리하는 secret key가 있어야 복호화가 가능하다.
        -   Signature 부분으로 토큰의 위변조 여부를 확인할 수 있다.
            ```json
            HMACSHA256(
              base64UrlEncode(header) + "." +
              base64UrlEncode(payload),
              secret)
            ```
    ### JWT의 작동
    !https://user-images.githubusercontent.com/96133075/218945769-f5486528-23b0-49c4-bbeb-f90b9ca553af.png
    1. 클라이언트가 ID, PW 로그인 요청을 보낸다.
    2. 회원 DB에서 사용자를 확인한다.
    3. 로그인 성공 시, 서버는 로그인 정보를 Payload에 담고, Secret Key를 사용해서 Access Token(JWT)을 발급한다.
    4. 서버가 JWT를 Client에 전달한다. 이 때 전달방법은 개발자가 정한다.

        ex) 응답 Header에 `Authorization: BEARER <JWT>` 형태로 전달

    5. 클라이언트는 전달받은 토큰(JWT)을 저장한다.(쿠키, local storage 등)
    6. 클라이언트가 서버에 요청할 때마다 토큰(JWT)을 요청 Header의 `Authorization` 에 포함시켜 함께 전달한다.
    7. 서버는 클라이언트가 전달한 토큰의 Signature를 secret Key로 복호화한 후, 위변조 여부 및 유효기간을 검증한다.
    8. 검증에 성공하면, JWT에서 사용자 정보를 확인하고 요청에 응답한다.
    ### JWT 장점
    -   동시 접속자가 많을 때 서버 부하를 낮춘다.
    -   클라이언트, 서버가 다른 도메인을 사용할 때 사용 가능하다.
        -   ex) 카카오 OAuth2 로그인 시 JWT 토큰 사용
    -   인증 정보를 서버에 별도로 저장할 필요가 없다. → 서버의 Stateless 특성이 유지된다.
    ### JWT 단점
    -   구현 복잡도가 증가한다.
    -   JWT에 담는 내용이 커질수록 네트워크 비용이 증가한다.
    -   이미 생성된 JWT를 일부만 만료시킬 방법이 없다. (토큰의 유효기간을 너무 길게 잡으면 안된다.)
    -   Secret Key 유출 시 JWT 조작이 가능하다.
    -   Payload 자체는 암호화되지 않기 때문에 사용자의 중요한 정보는 담을 수 없다.
    > JWT도 제 3자에게 토큰 탈취의 위험성이 있기 때문에, 그대로 사용하는것이 아닌 Access Token, Refresh Token 으로 이중으로 나누어 인증을 하는 방식을 현업에선 취한다.
    -   **Access Token** : **클라이언트**가 갖고있는 실제로 유저의 정보가 담긴 토큰으로, 클라이언트에서 요청이 오면 서버에서 해당 토큰에 있는 정보를 활용하여 사용자 정보에 맞게 응답을 진행
    -   **Refresh Token**: 새로운 Access Token을 발급해주기 위해 사용하는 토큰으로 짧은 수명을 가지는 Access Token에게 새로운 토큰을 발급해주기 위해 사용. 해당 토큰은 보통 **데이터베이스**에 유저 정보와 같이 기록.
-   토큰
    사용자가 로그인정보를 제공하면 일치여부 후 토큰 발급

JWT

**Oauth: Open Authorization 인가 방식**

[https://velog.io/@kimdy0915/인증-방식쿠키-세션-JWT에-대해-알아보자](https://velog.io/@kimdy0915/%EC%9D%B8%EC%A6%9D-%EB%B0%A9%EC%8B%9D%EC%BF%A0%ED%82%A4-%EC%84%B8%EC%85%98-JWT%EC%97%90-%EB%8C%80%ED%95%B4-%EC%95%8C%EC%95%84%EB%B3%B4%EC%9E%90)

[https://chan9.tistory.com/181#😄중요-1](https://chan9.tistory.com/181#%F0%9F%98%84%EC%A4%91%EC%9A%94-1)
